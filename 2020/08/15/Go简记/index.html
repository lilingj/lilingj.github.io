<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="变量声明   5种 一行一个1var name string &#x3D; &quot;Hello World!&quot; 使用    var    会对变量进行隐式初始化  * string：空字符串（双引号和单引号不等价） * int：0 * float：0.0 * bool：false * 指针：nil 简化： 12var name &#x3D; &quot;Hello World&amp;quo">
<meta property="og:type" content="article">
<meta property="og:title" content="Go简记">
<meta property="og:url" content="http://example.com/2020/08/15/Go%E7%AE%80%E8%AE%B0/index.html">
<meta property="og:site_name" content="换菜刀换脸盆">
<meta property="og:description" content="变量声明   5种 一行一个1var name string &#x3D; &quot;Hello World!&quot; 使用    var    会对变量进行隐式初始化  * string：空字符串（双引号和单引号不等价） * int：0 * float：0.0 * bool：false * 指针：nil 简化： 12var name &#x3D; &quot;Hello World&amp;quo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://uploader.shimo.im/f/HCElhDv3eryJ2fHu.png!thumbnail">
<meta property="article:published_time" content="2020-08-15T15:50:25.000Z">
<meta property="article:modified_time" content="2020-09-20T15:50:38.250Z">
<meta property="article:author" content="lilingj">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://uploader.shimo.im/f/HCElhDv3eryJ2fHu.png!thumbnail">

<link rel="canonical" href="http://example.com/2020/08/15/Go%E7%AE%80%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Go简记 | 换菜刀换脸盆</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">换菜刀换脸盆</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/15/Go%E7%AE%80%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="lilingj">
      <meta itemprop="description" content="昼短苦夜长，何不秉烛游？">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="换菜刀换脸盆">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go简记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-15 23:50:25" itemprop="dateCreated datePublished" datetime="2020-08-15T23:50:25+08:00">2020-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-20 23:50:38" itemprop="dateModified" datetime="2020-09-20T23:50:38+08:00">2020-09-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="变量声明-5种"><a href="#变量声明-5种" class="headerlink" title="变量声明   5种"></a>变量声明   5种</h1><ol>
<li><strong>一行一个</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var name string &#x3D; &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>
使用    var    会对变量进行隐式初始化</li>
</ol>
<pre><code>* string：空字符串（双引号和单引号不等价）
* int：0
* float：0.0
* bool：false
* 指针：nil</code></pre>
<p>简化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;Hello World&quot;</span><br><span class="line">var rate float32 &#x3D; 0.1</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><ol>
<li><p>多个变量同时声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">    name string &#x3D; &quot;duang!&quot;</span><br><span class="line">    age int</span><br><span class="line">    gender string</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 := ，推导声明写法 或者 短类型声明法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name :&#x3D; &quot;duang!&quot;</span><br><span class="line">integer :&#x3D; 15</span><br></pre></td></tr></table></figure>
<p>编译器会自动根据右值类型推断出左值的对应类型，只能用于函数内部</p>
</li>
<li><p>声明和初始化多个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name, age :&#x3D; &quot;zhangwei&quot;, 18</span><br></pre></td></tr></table></figure>
<p>与python类似，可用于变量交换</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b :&#x3D; 1, 2</span><br><span class="line">a, b &#x3D; b, a     &#x2F;&#x2F;swap(a, b)</span><br></pre></td></tr></table></figure>

<ol>
<li>new函数创建指针变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr :&#x3D; new(int)</span><br><span class="line">fmt.Println(&quot;ptr address: &quot;, ptr)</span><br><span class="line">fmt.Println(&quot;ptr value: &quot;, *ptr)</span><br></pre></td></tr></table></figure>
或者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var age int &#x3D; 18</span><br><span class="line">var ptr &#x3D; &amp;age</span><br></pre></td></tr></table></figure>
与C/C++指针相同<br>new函数只是个语法糖</li>
</ol>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ol>
<li>整形 和 无符号整形</li>
</ol>
<p><img src="https://uploader.shimo.im/f/HCElhDv3eryJ2fHu.png!thumbnail" alt="图片"></p>
<p>int 和 uint 在 32位系统 下占4个字节，在64位下占8个字节，为避免歧义，使用时表明位数，如 int32、uint64</p>
<p>不同进制表示方法：</p>
<p>2进制：0b 或 0B 为前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num int32 &#x3D; 0b10010</span><br></pre></td></tr></table></figure>
<p>8进制：0o 或 0O为前缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num int64 &#x3D; 0o77777</span><br></pre></td></tr></table></figure>
<p>16进制：0x</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num int8 &#x3D; 0xFFC8</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">    var num01 int &#x3D; 0b1100</span><br><span class="line">    var num02 int &#x3D; 0o14</span><br><span class="line">    var num03 int &#x3D; 0xC</span><br><span class="line">    fmt.Printf(&quot;2进制数 %b 表示的是: %d \n&quot;, num01, num01)</span><br><span class="line">    fmt.Printf(&quot;8进制数 %o 表示的是: %d \n&quot;, num02, num02)</span><br><span class="line">    fmt.Printf(&quot;16进制数 %X 表示的是: %d \n&quot;, num03, num03)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fmt包格式化功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%b    表示为二进制</span><br><span class="line">%c    该值对应的unicode码值</span><br><span class="line">%d    表示为十进制</span><br><span class="line">%o    表示为八进制</span><br><span class="line">%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x    表示为十六进制，使用a-f</span><br><span class="line">%X    表示为十六进制，使用A-F</span><br><span class="line">%U    表示为Unicode格式：U+1234，等价于&quot;U+%04X&quot;</span><br><span class="line">%T    显示数据类型</span><br></pre></td></tr></table></figure>

<ol>
<li>浮点型</li>
</ol>
<p>只能由十进制表示，分两种精度，float32 和 float 64</p>
<ul>
<li>float32：1位符号位，8位指数，23位尾数。精度只能提供大约6个十进制数</li>
<li>float64:1位符号，11位指数，52位尾数。精度只能提供大约15个十进制数</li>
</ul>
<ol>
<li>byte 和 rune</li>
</ol>
<p>byte占1字节，表示一个ASCII字符，与 uint8 没有本质区别</p>
<p>rune占4字节，表示一个Unicode字符，与 int32 没有本质区别。用单引号</p>
<ol>
<li>string</li>
</ol>
<p>多个字符组成，本质是一个 byte 数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var mystr01 sting &#x3D; &quot;hello&quot;</span><br><span class="line">    var mystr02 [5]byte &#x3D; [5]byte&#123;104, 101, 108, 108, 111&#125;</span><br><span class="line">    fmt.Printf(&quot;mystr01: %s\n&quot;, mystr01)</span><br><span class="line">    fmt.Printf(&quot;mystr02: %s&quot;, mystr02)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出相同</p>
<ol>
<li>数组</li>
</ol>
<p>一个数组可以由0个或多个元素组成，由于数组长度固定，Go中很少使用数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr [3]int&#123;1, 3, 0&#125;</span><br></pre></td></tr></table></figure>
<p>使用…让Go自己根据实际情况分配空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr [...]int&#123;1, 4, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p>定义类型别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type arr_with_len_3 [3]int</span><br><span class="line">var arr arr_with_len_3&#123;1, 3, 2&#125;</span><br><span class="line">&#x2F;&#x2F;初始化长度为3的数组 arr</span><br></pre></td></tr></table></figure>

<ol>
<li>切片</li>
</ol>
<p>引用类型，是数组的一个引用</p>
<p>3种声明方法：</p>
<p>对数组的片段截取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr :&#x3D; [...]int&#123;1, 2, 3&#125;</span><br><span class="line">sli :&#x3D; arr[0:2]</span><br></pre></td></tr></table></figure>
<p>从头声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var string_sli []string</span><br><span class="line">var num_sli []int&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用make函数构造，make函数格式：make([]Type, size, cap)，（类型，长度，容量）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; make([]int, 2)&#x2F;&#x2F;省略的cap &#x3D; size</span><br><span class="line">b :&#x3D; make([]int, 2, 10)</span><br><span class="line">&#x2F;&#x2F;显然cap &gt;&#x3D; size，当cap &gt; size时，多出来的空间可以使用append追加元素后访问</span><br><span class="line">myarr &#x3D; append(myarr, 2)&#x2F;&#x2F; 追加一个元素</span><br><span class="line">myarr &#x3D; append(myarr, 3, 4)&#x2F;&#x2F; 追加多个元素</span><br><span class="line">myarr &#x3D; append(myarr, []int&#123;7, 8&#125;...)&#x2F;&#x2F; 追加一个切片, ... 表示解包，不能省略</span><br><span class="line">myarr &#x3D; append([]int&#123;0&#125;, myarr...)&#x2F;&#x2F; 在第一个位置插入元素</span><br><span class="line">myarr &#x3D; append(myarr[:5], append([]int&#123;5,6&#125;, myarr[5:]...)...)&#x2F;&#x2F; 在中间插入一个切片(两个元素)</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>切片引用的依旧是原数组，利用切片修改数组值修改到原来数组值，这点与python的切片是复制一部分数组不同</p>
<p>切片参数说明 sli := arr[start : end : max]，如 sli := arr[4:6:8]，表示切片从原数组下标 4 到 6，最多访问到原数组下标为 8 的位置，意思是，sli[0] 到 sli[3] 都可以被访问到，若省略，则 max = end，其中 sli 的地址等于 arr[start] 的地址</p>
<ol>
<li>字典</li>
</ol>
<p>三种初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种方法</span><br><span class="line">var scores map[string]int &#x3D; map[string]int&#123;&quot;english&quot;: 80, &quot;chinese&quot;: 85&#125;</span><br><span class="line">&#x2F;&#x2F; 第二种方法</span><br><span class="line">scores :&#x3D; map[string]int&#123;&quot;english&quot;: 80, &quot;chinese&quot;: 85&#125;</span><br><span class="line">&#x2F;&#x2F; 第三种方法</span><br><span class="line">scores :&#x3D; make(map[string]int)</span><br><span class="line">scores[&quot;english&quot;] &#x3D; 80</span><br><span class="line">scores[&quot;chinese&quot;] &#x3D; 85</span><br></pre></td></tr></table></figure>
<p>key必须可哈希，不能是切片、字典、函数<br>相关操作</p>
<p>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores[&quot;math&quot;] &#x3D; 95</span><br></pre></td></tr></table></figure>
<p>更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores[&quot;math&quot;] &#x3D; 100</span><br></pre></td></tr></table></figure>
<p>读取若不存在，返回value类型的零值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(scores[&quot;math&quot;])</span><br></pre></td></tr></table></figure>
<p>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(scores, &quot;math&quot;)</span><br></pre></td></tr></table></figure>
<p>判断key是否存在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">math, ok :&#x3D; scores[&quot;math&quot;]</span><br><span class="line">&#x2F;&#x2F;若ok为true，则存在</span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  1. 获取 key 和 val</span><br><span class="line">for key, val :&#x3D; range scores &#123;</span><br><span class="line">    solve(key, val)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  2.只获取 key, 注意不用占位符</span><br><span class="line">for key :&#x3D; range scores &#123;</span><br><span class="line">    solve(key)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;  3只获取 value，使用占位符</span><br><span class="line">for _, val :&#x3D; range scores &#123;</span><br><span class="line">    solve(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>bool类型</li>
</ol>
<p>bool 和 int 不能直接转换，用法同C/C++</p>
<ol>
<li>指针</li>
</ol>
<p>零值为 nil，其余同C/C++。建议切片传值，而不用指针</p>
<h1 id="面向对象：结构体-和-组合"><a href="#面向对象：结构体-和-组合" class="headerlink" title="面向对象：结构体 和 组合"></a>面向对象：结构体 和 组合</h1><ol>
<li><p>定义结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">   name   string</span><br><span class="line">   age       int</span><br><span class="line">   father *Person</span><br><span class="line">   mother *Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4></li>
<li><p>定义方法</p>
</li>
</ol>
<p>注意：Person 和 <em>Person定义的变量 person 调用内部成员，一律是 person.age 这种形式，在方法中，若要修改结构体变量，必须用</em>Person定义person，建议使用指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type Person struct &#123;</span><br><span class="line">   name   string</span><br><span class="line">   age       int</span><br><span class="line">   father *Person</span><br><span class="line">   mother *Person</span><br><span class="line">&#125;</span><br><span class="line">func (person Person)GetAge() (int) &#123;</span><br><span class="line">   return person.age</span><br><span class="line">&#125;</span><br><span class="line">func (person *Person)SetAge(age int) &#123;</span><br><span class="line">   person.age &#x3D; age</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   llj :&#x3D; Person&#123;name:&quot;llj&quot;, age:18&#125;</span><br><span class="line">   llj.SetAge(20)</span><br><span class="line">   fmt.Println(llj.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>组合</li>
</ol>
<p>将几个结构体组合在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">type company struct &#123;</span><br><span class="line">    companyName string</span><br><span class="line">    companyAddr string</span><br><span class="line">&#125;</span><br><span class="line">type staff struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    age int</span><br><span class="line">    gender string</span><br><span class="line">    position string</span><br><span class="line">    company   &#x2F;&#x2F; 匿名字段 </span><br><span class="line">&#125;</span><br><span class="line">func main()  &#123;</span><br><span class="line">    myCom :&#x3D; company&#123;</span><br><span class="line">        companyName: &quot;Tencent&quot;,</span><br><span class="line">        companyAddr: &quot;深圳市南山区&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    staffInfo :&#x3D; staff&#123;</span><br><span class="line">        name:     &quot;小明&quot;,</span><br><span class="line">        age:      28,</span><br><span class="line">        gender:   &quot;男&quot;,</span><br><span class="line">        position: &quot;云计算开发工程师&quot;,</span><br><span class="line">        company: myCom,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;调用staffInfo.companyName 或 staffInfo.company.companyName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>内部方法 和 外部方法</li>
</ol>
<p>首字母大写，这个方法可以被所有包调用</p>
<p>首字母小写，这个方法其他包无法访问</p>
<h1 id="面向对象：接口和多态"><a href="#面向对象：接口和多态" class="headerlink" title="面向对象：接口和多态"></a>面向对象：接口和多态</h1><ol>
<li>接口</li>
</ol>
<p>Go中，接口是方法签名（Method Signature）的集合</p>
<p>定义接口：使用type关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Phone interface &#123;</span><br><span class="line">   call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口：接口实现是隐式的，不需要显示声明。如果一个结构体实现了一个接口的所有方法，就可以称它实现了该接口</p>
<ol>
<li>多态</li>
</ol>
<p>使用接口来实现多态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">&#x2F;&#x2F;接口</span><br><span class="line">type Jiao interface &#123;</span><br><span class="line">   call()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;父类</span><br><span class="line">type Animal struct &#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类cat</span><br><span class="line">type Cat struct &#123;</span><br><span class="line">   Animal</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类cat实现Jiao接口</span><br><span class="line">func (cat Cat) call() &#123;</span><br><span class="line">   fmt.Println(cat.name + &quot; miao miao&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类dog</span><br><span class="line">type Dog struct &#123;</span><br><span class="line">   Animal</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类dog实现Jiao接口</span><br><span class="line">func (dog Dog) call()  &#123;</span><br><span class="line">   </span><br><span class="line">   fmt.Println(dog.name + &quot; wangwang&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;用接口接受参数，实现多态</span><br><span class="line">func KillAnimal(jiao Jiao) &#123;</span><br><span class="line">   jiao.call()</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   cat :&#x3D; Cat&#123;Animal&#123;name:&quot;cat&quot;&#125;&#125;</span><br><span class="line">   dog :&#x3D; Dog&#123;Animal&#123;name:&quot;dog&quot;&#125;&#125;</span><br><span class="line">   KillAnimal(cat)</span><br><span class="line">   KillAnimal(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>可变参数</li>
</ol>
<p>类型一致：使用…int表示该类型的一个切片，…也可用来解序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func sum(args ...int) int &#123;</span><br><span class="line">    var sum int</span><br><span class="line">    for _, v :&#x3D; range args &#123;</span><br><span class="line">        sum +&#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line">func Sum(args ...int) int &#123;</span><br><span class="line">    &#x2F;&#x2F; 利用 ... 来解序列</span><br><span class="line">    result :&#x3D; sum(args...)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(sum(1, 2, 3))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型不一致：使用…interface{}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">func MyPrintf(args ...interface&#123;&#125;) &#123;</span><br><span class="line">    for _, arg :&#x3D; range args &#123;</span><br><span class="line">        switch arg.(type) &#123;</span><br><span class="line">            case int:</span><br><span class="line">                fmt.Println(arg, &quot;is an int value.&quot;)</span><br><span class="line">            case string:</span><br><span class="line">                fmt.Println(arg, &quot;is a string value.&quot;)</span><br><span class="line">            case int64:</span><br><span class="line">                fmt.Println(arg, &quot;is an int64 value.&quot;)</span><br><span class="line">            default:</span><br><span class="line">                fmt.Println(arg, &quot;is an unknown type.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var v1 int &#x3D; 1</span><br><span class="line">    var v2 int64 &#x3D; 234</span><br><span class="line">    var v3 string &#x3D; &quot;hello&quot;</span><br><span class="line">    var v4 float32 &#x3D; 1.234</span><br><span class="line">    MyPrintf(v1, v2, v3, v4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>匿名函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func(参数列表)(返回参数列表)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第二个参数为函数</span><br><span class="line">func visit(list []int, f func(int)) &#123;</span><br><span class="line">    for _, v :&#x3D; range list &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        f(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用匿名函数直接做为参数</span><br><span class="line">    visit([]int&#123;1, 2, 3, 4&#125;, func(v int) &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><ol>
<li>if-else 语句</li>
</ol>
<p>对 { 和 } 有严格要求，else if 或 else 两边的花括号必须在同一行</p>
<p>模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if 条件 1 &#123;</span><br><span class="line">  分支 1</span><br><span class="line">&#125; else if 条件 2 &#123;</span><br><span class="line">  分支 2</span><br><span class="line">&#125; else if 条件 ... &#123;</span><br><span class="line">  分支 ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  分支 else</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特殊写法：先运行一个表达式，获得变量后再对其进行判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if age :&#x3D; 20;age &gt; 18 &#123;</span><br><span class="line">    fmt.Println(&quot;已经成年了&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>swith-case 语句</li>
</ol>
<p>知道有就行，学习各种语言从没用过这个语法</p>
<ol>
<li>循环语句：for</li>
</ol>
<p>三种用法</p>
<p>接一个表达式，即当别的语言的while用，没有表达式时相当于表达式是true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a :&#x3D; 1</span><br><span class="line">for a &lt;&#x3D; 5 &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    a ++ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接三个，正常用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 5; i++ &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for-range 语句<br>range 后可接数组、切片、字符串等，返回两个值：索引、数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myarr :&#x3D; [...]string&#123;&quot;world&quot;, &quot;python&quot;, &quot;go&quot;&#125;</span><br><span class="line">for _, item :&#x3D; range myarr &#123;</span><br><span class="line">    fmt.Printf(&quot;hello, %s\n&quot;, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>goto语句</li>
</ol>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    goto flag</span><br><span class="line">    fmt.Println(&quot;B&quot;)</span><br><span class="line">flag:</span><br><span class="line">    fmt.Println(&quot;A&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，goto语句和标签之间不能有变量声明</p>
<ol>
<li>defer延迟调用</li>
</ol>
<p>用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defer func()</span><br></pre></td></tr></table></figure>
<p>效果：记录当前函数需要的参数，压入栈中，当前函数执行完后（return后），依次弹栈执行</p>
<h1 id="关键字-make-和-new"><a href="#关键字-make-和-new" class="headerlink" title="关键字 make 和 new"></a>关键字 make 和 new</h1><ol>
<li>new</li>
</ol>
<p>接受一个参数，该参数为一个任意类型，返回这个类型的指针，具体做三件事：</p>
<pre><code>    * 分配内存
    * 设置零值
    * 返回指针</code></pre>
<p>new 不常用</p>
<ol>
<li>make</li>
</ol>
<p>专为 slice，map，chan 类型分配内存和初始化一个对象，返回类型本身</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;切片</span><br><span class="line">a :&#x3D; make([]int, 2, 10)  </span><br><span class="line">&#x2F;&#x2F; 字典</span><br><span class="line">b :&#x3D; make(map[string]int)</span><br><span class="line">&#x2F;&#x2F; 通道</span><br><span class="line">c :&#x3D; make(chan int, 10)</span><br></pre></td></tr></table></figure>


<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>类C/C++</p>
<h1 id="Go协程：goroutine"><a href="#Go协程：goroutine" class="headerlink" title="Go协程：goroutine"></a>Go协程：goroutine</h1><ol>
<li>简介</li>
</ol>
<p>Go 从语言层面天生支持并发。goroutine 是Go 语言程序并发执行的基本单元，它本身是一个函数，直接调用时是一个普通函数，调用前加一个关键字 go ，就开启了一个goroutine</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行一个函数</span><br><span class="line">func()</span><br><span class="line">&#x2F;&#x2F; 开启一个协程执行这个函数</span><br><span class="line">go func()</span><br></pre></td></tr></table></figure>
<p>一个 Go 程序入口通常是 main 函数，程序启动后，main最先运行，称之为 main goroutine</p>
<ol>
<li>信道</li>
</ol>
<p>多个 goroutine 的通信需要依赖 channel，它是一种队列式的数据结构，遵循先入先出的规则。每个信道只能传递一种数据类型的数据</p>
<p>不要通过共享内存来通信，而通过通信来共享内存</p>
<ol>
<li><p>信道的声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var 信道实例 chan 信道类型 &#x3D; make(chan 信道类型)</span><br><span class="line">信道实例 :&#x3D; make(chan 信道实例)</span><br><span class="line">&#x2F;&#x2F;如：</span><br><span class="line">pipline :&#x3D; make(chan int)</span><br></pre></td></tr></table></figure>
<p>chan的类型零值为nil</p>
</li>
<li><p>关闭信道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(pipline)</span><br></pre></td></tr></table></figure>
<p>只能关闭一次，重复关闭会报错</p>
</li>
<li><p>信道的数据操作</p>
<ul>
<li>发送数据</li>
<li>读取数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;往信道中发送数据</span><br><span class="line">pipline&lt;- 200</span><br><span class="line">&#x2F;&#x2F;从信道中取出数据，并复制给mydata</span><br><span class="line">mydata :&#x3D; &lt;-pipline</span><br><span class="line">mydata, ok :&#x3D; &lt;-pipline</span><br></pre></td></tr></table></figure>
ok 表示信道是否被关闭，关闭：false，未关：true</li>
</ul>
</li>
<li><p>信道的容量和长度</p>
</li>
</ol>
<p>使用make函数创建信道，需要两个参数，第二个信道容量，选填，不填为0</p>
<pre><code>* 容量为 0 时，称为无缓冲信道，信道不能存放数据，发送时必须马上有人接受，否则报错。
* 容量为 1 时，只能缓存一个数据。若已有一个数据，再发送数据会造成程序阻塞。利用这点让信道来做锁
* 容量大于 1 时，用于多个协程之间，成为他们的通信管道，共享资源</code></pre>
<p>可以使用 cap 函数获取信道容量，len 函数获取信道长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cap(pipline)</span><br><span class="line">len(pipline)</span><br></pre></td></tr></table></figure>

<ol>
<li>缓冲信道和无缓冲信道</li>
</ol>
<p>缓冲信道：允许信道存储一个或多个数据，发送端和接收端可以处于异步状态</p>
<p>无缓冲信道：容量为0，接收端必须先于发送端准备好，否则发送端会阻塞</p>
<ol>
<li>双向信道和单向信道</li>
</ol>
<p>双向信道：可读可写</p>
<p>单向信道：可读或可写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var pipline &#x3D; make(chan int)</span><br><span class="line">type Receiver &#x3D; &lt;-chan int &#x2F;&#x2F; 关键代码：定义别名类型</span><br><span class="line">var receiver Receiver &#x3D; pipline</span><br><span class="line">type Sender &#x3D; chan&lt;- int  &#x2F;&#x2F; 关键代码：定义别名类型</span><br><span class="line">var sender Sender &#x3D; pipline</span><br></pre></td></tr></table></figure>

<ol>
<li>遍历信道</li>
</ol>
<p>for-range遍历信道，要确保信道关闭，否则循环会阻塞</p>
<ol>
<li><p>信道做锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import &#123;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 由于 x&#x3D;x+1 不是原子操作</span><br><span class="line">&#x2F;&#x2F; 所以应避免多个协程对x进行操作</span><br><span class="line">&#x2F;&#x2F; 使用容量为1的信道可以达到锁的效果</span><br><span class="line">func increment(ch chan bool, x *int) &#123;  </span><br><span class="line">    ch &lt;- true</span><br><span class="line">    *x &#x3D; *x + 1</span><br><span class="line">    &lt;- ch</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F; 注意要设置容量为 1 的缓冲信道</span><br><span class="line">    pipline :&#x3D; make(chan bool, 1)</span><br><span class="line">    var x int</span><br><span class="line">    for i:&#x3D;0;i&lt;1000;i++&#123;</span><br><span class="line">        go increment(pipline, &amp;x)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 确保所有的协程都已完成</span><br><span class="line">    &#x2F;&#x2F; 以后会介绍一种更合适的方法（Mutex），这里暂时使用sleep</span><br><span class="line">    time.Sleep(3)</span><br><span class="line">    fmt.Println(&quot;x 的值：&quot;, x)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>WaitGroup</p>
</li>
</ol>
<p>使用WaitGroup 来保证所有 goroutine 都执行完</p>
<p>WaitGroup在 sync 包中，实例化了就能用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 实例名 sync.WaitGroup</span><br></pre></td></tr></table></figure>
<p>有三个方法：</p>
<pre><code>* Add：计数器初始值为0，传入值后会往计数器上加，传入子协程数量即可
* Done：某个子协程完成后，可调用此方法，会从计数器上减一，通常使用 defer 调用
* Wait：阻塞当前协程，知道实例里的计数器归零</code></pre>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">func worker(x int, wg *sync.WaitGroup) &#123;</span><br><span class="line">    defer wg.Done()</span><br><span class="line">    for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class="line">        fmt.Printf(&quot;worker %d: %d\n&quot;, x, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    wg.Add(2)</span><br><span class="line">    go worker(1, &amp;wg)</span><br><span class="line">    go worker(2, &amp;wg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>读写锁和互斥锁</li>
</ol>
<p>面对并发问题，应该优先考虑使用信道，如果必须共享内存，那只能利用Go 中的锁机制</p>
<p>互斥锁：Mutex</p>
<p>声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种</span><br><span class="line">var lock *sync.Mutex</span><br><span class="line">lock &#x3D; new(sync.Mutex)</span><br><span class="line">&#x2F;&#x2F; 第二种</span><br><span class="line">lock :&#x3D; &amp;sync.Mutex&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">func add(count *int, wg *sync.WaitGroup, lock *sync.Mutex) &#123;</span><br><span class="line">    for i :&#x3D; 0; i &lt; 1000; i++ &#123;</span><br><span class="line">        lock.Lock()</span><br><span class="line">        *count &#x3D; *count + 1</span><br><span class="line">        lock.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line">    lock :&#x3D; &amp;sync.Mutex&#123;&#125;</span><br><span class="line">    count :&#x3D; 0</span><br><span class="line">    wg.Add(3)</span><br><span class="line">    go add(&amp;count, &amp;wg, lock)</span><br><span class="line">    go add(&amp;count, &amp;wg, lock)</span><br><span class="line">    go add(&amp;count, &amp;wg, lock)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(&quot;count 的值为：&quot;, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读写锁：RWMutex</p>
<p>互斥锁傻瓜式操作，效率低下，读写锁分解了互斥锁的步骤，进行更精细的权限分派</p>
<p>将程序对资源的访问分为读操作和写操作</p>
<p>规定：</p>
<pre><code>* 规定有人读时，不允许有人写，可以多人读
* 规定有人写时，不允许有人读写</code></pre>
<p>即，有多个读锁和一个写锁提供，获取某个锁时另一种锁必须在全部归还状态</p>
<p>声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一种</span><br><span class="line">var lock *sync.RWMutex</span><br><span class="line">lock &#x3D; new(sync.RWMutex)</span><br><span class="line">&#x2F;&#x2F; 第二种</span><br><span class="line">lock :&#x3D; &amp;sync.RWMutex&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<pre><code>* 读锁：调用RLock获取，RUnlock释放
* 写锁：调用WLock获取，WUnlock释放</code></pre>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ol>
<li><p>触发 panic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic(&quot;fuck you!&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>捕获panic</p>
</li>
</ol>
<p>使用内建函数 recover 捕获 panic，recover必须在 defer 函数中才能生效</p>
<p>没有 recover， 触发 panic 之前调用的 defer 函数也会执行完，若有上一级函数调用，上一级函数调用该函数之前调用的 defer 函数也会执行完，以此类推</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &quot;fmt&quot;</span><br><span class="line">func set_data(x int) &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        &#x2F;&#x2F; recover() 可以将捕获到的panic信息打印</span><br><span class="line">        if err :&#x3D; recover(); err !&#x3D; nil &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &#x2F;&#x2F; 故意制造数组越界，触发 panic</span><br><span class="line">    var arr [10]int</span><br><span class="line">    arr[x] &#x3D; 88</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    set_data(20)</span><br><span class="line">    &#x2F;&#x2F; 如果能执行到这句，说明panic被捕获了</span><br><span class="line">    &#x2F;&#x2F; 后续的程序能继续运行</span><br><span class="line">    fmt.Println(&quot;everything is ok&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>recover 无法跨协程</li>
</ol>
<p>同上，层级调用会依次触发上一级的之前调用的 defer 函数，但协程之间不会</p>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>略</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>给我一块钱，可以不可以</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="lilingj 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="lilingj 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/05/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0/" rel="prev" title="区块链笔记">
      <i class="fa fa-chevron-left"></i> 区块链笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/20/Docker%E7%AE%80%E8%AE%B0/" rel="next" title="Docker简记">
      Docker简记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E-5%E7%A7%8D"><span class="nav-number">1.</span> <span class="nav-text">变量声明   5种</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.0.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93-%E5%92%8C-%E7%BB%84%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">面向对象：结构体 和 组合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#-1"><span class="nav-number">3.0.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">面向对象：接口和多态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">6.</span> <span class="nav-text">流程控制语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97-make-%E5%92%8C-new"><span class="nav-number">7.</span> <span class="nav-text">关键字 make 和 new</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">8.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go%E5%8D%8F%E7%A8%8B%EF%BC%9Agoroutine"><span class="nav-number">9.</span> <span class="nav-text">Go协程：goroutine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">11.</span> <span class="nav-text">包</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lilingj"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">lilingj</p>
  <div class="site-description" itemprop="description">昼短苦夜长，何不秉烛游？</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lilingj</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
